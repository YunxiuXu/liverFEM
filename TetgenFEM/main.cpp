
//#define EIGEN_USE_MKL_ALL
#include <iostream>
#include <vector>
#include <cstring>  // for std::strcpy
#include "tetgen.h"  // Include the TetGen header file
#include <fstream>
#include "GL/glew.h" 
#include "GLFW/glfw3.h"
#include "params.h"
#include <cmath>
#include <random>
#include "VisualOpenGL.h"
#include "ReadSTL.h"
#include "Object.h"
#include "Vertex.h"
#include "Edge.h"



//C:/Users/xu_yu/Desktop/tmp/arial.ttf
 
// Global variables to store zoom factor and transformation matrix

Eigen::Matrix4f transformationMatrix = Eigen::Matrix4f::Identity();
int wKey = 0;

void saveOBJ(const std::string& filename, std::vector<Group>& groups) {
	std::ofstream objFile(filename);
	if (!objFile.is_open()) {
		std::cerr << "Failed to open file for writing.\n";
		return;
	}

	std::unordered_map<Vertex*, int> vertexIndexMap;
	int currentIndex = 1;

	// 遍历组，找出所有边界边并记录其顶点
	for (const auto& group : groups) {
		for (const auto* tet : group.tetrahedra) {
			for (const auto* edge : tet->edges) {
				if (edge->isBoundary) {
					for (Vertex* vertex : edge->vertices) {
						if (vertexIndexMap.find(vertex) == vertexIndexMap.end()) {
							vertexIndexMap[vertex] = currentIndex++;
							objFile << "v " << vertex->x << " " << vertex->y << " " << vertex->z << "\n";
						}
					}
				}
			}
		}
	}

	// 再次遍历，这次是为了构建面
	for (const auto& group : groups) {
		for (const auto* tet : group.tetrahedra) {
			for (const auto* edge : tet->edges) {
				if (edge->isBoundary) {
					objFile << "f";
					for (Vertex* vertex : edge->vertices) {
						objFile << " " << vertexIndexMap[vertex];
					}
					objFile << "\n";
				}
			}
		}
	}

	objFile.close();
	std::cout << "OBJ file saved: " << filename << "\n";
}
void writeOBJ(const Object& object, const std::string& filename) {
	std::ofstream file(filename);
	if (!file.is_open()) {
		std::cerr << "Failed to open file for writing.\n";
		return;
	}

	int vertexIndexOffset = 1;
	std::unordered_map<Vertex*, int> vertexIndexMap;

	for (const auto& group : object.groups) {
		for (const auto& tetrahedron : group.tetrahedra) {
			// vertex
			for (int i = 0; i < 4; ++i) {
				Vertex* vertex = tetrahedron->vertices[i];
				if (vertexIndexMap.find(vertex) == vertexIndexMap.end()) {
					vertexIndexMap[vertex] = vertexIndexOffset++;
					file << "v " << vertex->x << " " << vertex->y << " " << vertex->z << "\n";
				}
			}

			// writing faces
			// indices of four faces
			int indices[4][3] = { {0, 1, 2}, {0, 1, 3}, {1, 2, 3}, {0, 2, 3} };
			for (int i = 0; i < 4; ++i) {
				file << "f";
				for (int j = 0; j < 3; ++j) {
					file << " " << vertexIndexMap[tetrahedron->vertices[indices[i][j]]];
				}
				file << "\n";
			}
		}
	}

	file.close();
	std::cout << "OBJ file has been written.\n";
}
void writeSTL(const Object& object, const std::string& filename) {
	std::ofstream file(filename, std::ios::binary);
	if (!file.is_open()) {
		std::cerr << "Failed to open file for writing.\n";
		return;
	}

	// Write 80-byte header
	char header[80];
	memset(header, 0, sizeof(header)); // Fill header with zeros
	std::string description = "Binary STL generated by writeSTL function";
	std::memcpy(header, description.c_str(), std::min(description.size(), sizeof(header)));
	file.write(header, sizeof(header));

	// Count total number of triangles
	uint32_t totalTriangles = 0;
	for (const auto& group : object.groups) {
		for (const auto& tetrahedron : group.tetrahedra) {
			totalTriangles += 4; // Each tetrahedron has 4 triangular faces
		}
	}
	file.write(reinterpret_cast<char*>(&totalTriangles), sizeof(totalTriangles));

	// Write triangles
	for (const auto& group : object.groups) {
		for (const auto& tetrahedron : group.tetrahedra) {
			// Indices for the four triangular faces of a tetrahedron
			int indices[4][3] = { {0, 1, 2}, {0, 1, 3}, {1, 2, 3}, {0, 2, 3} };

			for (int i = 0; i < 4; ++i) {
				// Write normal vector (defaulting to 0,0,0)
				float normal[3] = { 0.0f, 0.0f, 0.0f };
				file.write(reinterpret_cast<char*>(normal), sizeof(normal));

				// Write vertices of the triangle
				for (int j = 0; j < 3; ++j) {
					Vertex* vertex = tetrahedron->vertices[indices[i][j]];
					float vertexCoords[3] = { static_cast<float>(vertex->x),
											 static_cast<float>(vertex->y),
											 static_cast<float>(vertex->z) };
					file.write(reinterpret_cast<char*>(vertexCoords), sizeof(vertexCoords));
				}

				// Write attribute byte count (2 bytes, set to 0)
				uint16_t attributeByteCount = 0;
				file.write(reinterpret_cast<char*>(&attributeByteCount), sizeof(attributeByteCount));
			}
		}
	}

	file.close();
	std::cout << "Binary STL file has been written.\n";
}
void findTopAndBottomVertices(const std::vector<Group>& groups, std::vector<int>& topVertexLocalIndices, std::vector<int>& bottomVertexLocalIndices) {
	for (const Group& g : groups) {
		for (const auto& vertexPair : g.verticesMap) {
			Vertex* vertex = vertexPair.second;
			if (vertex->inity > 0.53) {
				topVertexLocalIndices.push_back(vertex->index);
			}
			if (vertex->inity < -0.53) {
				bottomVertexLocalIndices.push_back(vertex->index);
			}
		}
	}
}
void findMaxAndMinYVertices(const std::vector<Group>& groups, int& maxYVertexIndex, int& minYVertexIndex) {
	bool isFirstVertex = true;
	double maxY = 0.0;
	double minY = 0.0;

	for (const Group& g : groups) {
		for (const auto& vertexPair : g.verticesMap) {
			Vertex* vertex = vertexPair.second;

			if (isFirstVertex) {
				// Initialize maxY and minY with the first vertex's y-coordinate
				maxY = minY = vertex->inity;
				maxYVertexIndex = minYVertexIndex = vertex->index;
				isFirstVertex = false;
			}
			else {
				if (vertex->inity > maxY) {
					maxY = vertex->inity;
					maxYVertexIndex = vertex->index;
				}
				if (vertex->inity < minY) {
					minY = vertex->inity;
					minYVertexIndex = vertex->index;
				}
			}
		}
	}
}

void findUpperAndLowerVertices(const std::vector<Group>& groups, std::vector<int>& upperVertices, std::vector<int>& lowerVertices) {
	double sumInity = 0.0;
	int count = 0;

	// First pass: calculate the average inity
	for (const Group& g : groups) {
		for (const auto& vertexPair : g.verticesMap) {
			Vertex* vertex = vertexPair.second;
			sumInity += vertex->inity;
			count++;
		}
	}

	double averageInity = sumInity / count;

	// Second pass: classify vertices based on average inity
	for (const Group& g : groups) {
		for (const auto& vertexPair : g.verticesMap) {
			Vertex* vertex = vertexPair.second;
			if (vertex->inity > averageInity) {
				upperVertices.push_back(vertex->index);
			}
			else {
				lowerVertices.push_back(vertex->index);
			}
		}
	}
}

int main() {

	loadParams("parameters.txt");

	tetgenio in, out;
	in.firstnumber = 1;  // All indices start from 1
	
	if (useDirectLoading) {
		// Direct loading mode: load node and element files without meshing
		std::cout << "Using direct loading mode with node file: " << nodeFile << " and element file: " << eleFile << std::endl;
		
		// Extract base filename without extension for TetGen (it will append .node and .ele automatically)
		std::string nodeFileBase = nodeFile;
		size_t nodeExtPos = nodeFileBase.find_last_of('.');
		if (nodeExtPos != std::string::npos) {
			nodeFileBase = nodeFileBase.substr(0, nodeExtPos);
		}
		
		std::string eleFileBase = eleFile;
		size_t eleExtPos = eleFileBase.find_last_of('.');
		if (eleExtPos != std::string::npos) {
			eleFileBase = eleFileBase.substr(0, eleExtPos);
		}
		
		char* nodeFileC = const_cast<char*>(nodeFileBase.c_str());
		char* eleFileC = const_cast<char*>(eleFileBase.c_str());
		
		std::cout << "Loading base filename: " << nodeFileBase << " (TetGen will append .node/.ele)" << std::endl;
		
		if (!in.load_node(nodeFileC)) {
			std::cerr << "Error loading .node file: " << nodeFileBase << ".node" << std::endl;
			return 1;
		}
		
		if (!in.load_tet(eleFileC)) {
			std::cerr << "Error loading .ele file: " << eleFileBase << ".ele" << std::endl;
			return 1;
		}
		
		// Copy input directly to output without meshing
		out = in;
	} else {
		// STL meshing mode: load STL file and use TetGen for meshing
		std::cout << "Using STL meshing mode with file: " << stlFile << std::endl;
		
		readSTL(stlFile.c_str(), in);
		
		// Configure TetGen behavior
		tetgenbehavior behavior;
		char* args = const_cast<char*>(tetgenArgs.c_str());
		behavior.parse_commandline(args);
		
		// Call TetGen to tetrahedralize the geometry
		tetrahedralize(&behavior, &in, &out);
	}
	



	Object object;
	groupNum = groupNumX * groupNumY * groupNumZ;
	object.groupNum = groupNum;
	object.groupNumX = groupNumX;
	object.groupNumY = groupNumY;
	object.groupNumZ = groupNumZ;
	divideIntoGroups(out, object, groupNumX, groupNumY, groupNumZ); //convert tetgen to our data structure

	/*out.save_nodes("vbdbeam");
	out.save_elements("vbdbeam");*/
	//writeSTL(object, "vbdbeam.stl");
	//writeOBJ(object, "vbdbeam.obj");


	object.updateIndices(); 
	object.assignLocalIndicesToAllGroups(); 
	object.generateUniqueVertices();
	
	object.updateAdjacentGroupIndices(groupNumX, groupNumY, groupNumZ);
	for (int i = 0; i < groupNum; ++i) {
	
		object.storeAdjacentGroupsCommonVertices(i);
	}
	
	// Accessing and printing the groups and their tetrahedra
//#pragma omp parallel for
	for (int i = 0; i < groupNum; ++i) {  // Loop over the groups
		Group& group = object.getGroup(i);
		std::cout << "Group " << i << " has " << group.tetrahedra.size() << " tetrahedra." << std::endl;
		group.LHS_I = Eigen::MatrixXf::Identity(3 * group.verticesMap.size(), 3 * group.verticesMap.size()); //ｽﾚﾊ｡ﾊｱｼ菻｡ﾄﾜﾊﾖ
	}


	// Initialize the GLFW library
	if (!glfwInit()) {
		return -1;
	}

	// Create a windowed mode window and its OpenGL context
	GLFWwindow* window = glfwCreateWindow(1080, 1080, "Tetrahedral Mesh Visualization", NULL, NULL);
	if (!window) {
		glfwTerminate();
		return -1;
	}

	// Make the window's context current
	glfwMakeContextCurrent(window);
	// Set scroll callback
	glfwSetScrollCallback(window, scroll_callback);
	glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
	glfwSetMouseButtonCallback(window, mouseButtonCallback);
	glfwSetCursorPosCallback(window, cursorPosCallback);

	Eigen::MatrixXd Ke;
	//Ke = object.groups[1].tetrahedra[0]->createElementK(youngs, poisson, );

	Eigen::Matrix4f mat;
	initFontData();
	//object.findCommonVertices();
	//object.commonPoints = object.findCommonVertices1(object.groups[0], object.groups[1]);
	//object.commonPoints1 = object.findCommonVertices1(object.groups[1], object.groups[2]);
	//object.commonPoints2 = object.findCommonVertices1(object.groups[2], object.groups[3]);
	//object.commonPoints3 = object.findCommonVertices1(object.groups[3], object.groups[4]);
	//std::pair<std::vector<Vertex*>, std::vector<Vertex*>> commonVertices2 = object.findCommonVertices1(object.groups[0], object.groups[1]);
	for (Group& g : object.groups) {
		
		for (const auto& vertexPair : g.verticesMap) {
			// ｶﾔﾃｿｸ･ｵ羞ﾃsetFixedIfBelowThresholdｷｽｷｨ
			Vertex* vertex = vertexPair.second;
			/*if (vertex->x > 0.91189f && vertex->y > 1.1693f)
				vertex->isFixed = true;*/
			// vertex->setFixedIfBelowThreshold(); // 注释掉，改用统一的方法
		}

	}
	
	// 使用新的方法固定左上10%的点
	object.fixTopLeft10PercentVertices();
	
	// 额外测试：手动固定前几个顶点
	int testFixedCount = 0;
	for (Group& g : object.groups) {
		for (const auto& vertexPair : g.verticesMap) {
			Vertex* vertex = vertexPair.second;
			if (testFixedCount < 5) { // 固定前5个顶点用于测试
				vertex->isFixed = true;
				std::cout << "TEST: Manually fixed vertex " << vertex->index 
					<< " at (" << vertex->initx << ", " << vertex->inity << ", " << vertex->initz << ")" << std::endl;
				testFixedCount++;
			}
		}
		if (testFixedCount >= 5) break;
	}
	
	std::vector<int> topVertexLocalIndices;
	std::vector<int> bottomVertexLocalIndices;

	findTopAndBottomVertices(object.groups, topVertexLocalIndices, bottomVertexLocalIndices);
	int maxYIndex, minYIndex;
	findMaxAndMinYVertices(object.groups, maxYIndex, minYIndex);


	// Now topVertexLocalIndices and bottomVertexLocalIndices contain the local indices of the top and bottom vertices, respectively.

	
	//Fix by several vertices
	//float maxY = -std::numeric_limits<float>::infinity();
	//Vertex* vertexWithMaxY = nullptr;
	
	//for (Group& g : object.groups) {
	//	for (const auto& vertexPair : g.verticesMap) {
	//		Vertex* vertex = vertexPair.second;
	//		if (vertex->y > maxY) {
	//			maxY = vertex->y;
	//			vertexWithMaxY = vertex;
	//		}
	//	}
	//}
	
	//if (vertexWithMaxY != nullptr) {
	//	vertexWithMaxY->isFixed = true;
	//	
	//}
	/////////
	
#pragma omp parallel for
	for (int i = 0; i < object.groupNum; ++i) {
		object.groups[i].calMassMatrix(density);
		object.groups[i].calDampingMatrix();
		object.groups[i].calCenterofMass();
		object.groups[i].calInitCOM();//initial com
		object.groups[i].calLocalPos(); // initial local positions
		object.groups[i].calGroupK(youngs, poisson);	
		//object.groups[i].calGroupKAni(youngs1, youngs2, youngs3, poisson);
		object.groups[i].setVertexMassesFromMassMatrix();//vertex mass
		object.groups[i].calMassGroup();
		object.groups[i].calMassDistributionMatrix();
		//object.groups[i].inverseTerm = (object.groups[i].massMatrix + object.groups[i].dampingMatrix * 0.01f).inverse(); 
		//object.groups[i].inverseTermSparse = object.groups[i].inverseTerm.sparseView();
		object.groups[i].calLHS();
	}

	//for calculate frame rate
	double lastTime = glfwGetTime();
	int nbFrames = 0;
	glfwSwapInterval(0);


	//------------------- save coordinates
	std::vector<Vertex*> objectUniqueVertices;

	for (int groupIdx = 0; groupIdx < groupNum; ++groupIdx) {
		Group& group = object.getGroup(groupIdx);
		auto& verticesMap = group.verticesMap; 

		for (const auto& pair : verticesMap) {
			bool found = false;
			for (const auto& vertex : objectUniqueVertices) {
				if (vertex->x == pair.second->initx && vertex->inity == pair.second->inity && vertex->initz == pair.second->initz) {
					found = true;
					break;
				}
			}
			if (!found) {
				objectUniqueVertices.push_back(pair.second);
			}
		}
	}

	std::sort(objectUniqueVertices.begin(), objectUniqueVertices.end(), [](const Vertex* a, const Vertex* b) {
		return a->index < b->index;
		});//index from min to max

	

	int frame = 1;
	while (!glfwWindowShouldClose(window)) {

		//object.commonPoints1 = object.findCommonVertices(object.groups[1], object.groups[2]);
		

		if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) {
			wKey = 1;

		}
		else if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) {
			wKey = 2;

		}
		else if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) {
			wKey = 3;

		}
		else if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS) {
			wKey = 4;

		}
		else
			wKey = 0;
		//std::cout << wKey << std::endl;
		//double aa = object.groups[0].tetrahedra[0]->calMassTetra(density);
#pragma omp parallel for
		for (int i = 0; i < groupNum; i++) {
			//object.groups[i].calGroupKFEM(youngs, poisson);
			object.groups[i].calPrimeVec();
			//object.groups[i].calPrimeVecS(topVertexLocalIndices, bottomVertexLocalIndices);
			//object.groups[i].calPrimeVec2(wKey);
			//object.groups[i].calPrimeVec(wKey);
			
			//object.groups[i].calPrimeVecT(wKey);
			/*object.groups[i].calLHSFEM();
			object.groups[i].calRHSFEM();
			object.groups[i].calDeltaXFEM();
			object.groups[i].calculateCurrentPositionsFEM();
			object.groups[i].updateVelocityFEM();
			object.groups[i].updatePositionFEM();*/

			object.groups[i].calRotationMatrix();

		}
		/*for (int i = 0; i < groupNum; i++) {
			std::cout << "Group" << i << "Prime vector is" << std::endl << object.groups[i].primeVec;
		}*/


		object.PBDLOOP(10);

		if (glfwGetKey(window, GLFW_KEY_C) == GLFW_PRESS) {
			std::ofstream file("vbdcomp_our.txt", std::ios::out | std::ios::trunc);
			if (!file.is_open()) {
				std::cerr << "Failed to open file." << std::endl;
				return 0;
			}
			for (int i = 0; i < objectUniqueVertices.size(); i++) {
				file << i + 1 << " " << objectUniqueVertices[i]->x << " " << objectUniqueVertices[i]->y << " " << objectUniqueVertices[i]->z << std::endl;
			}
			file.close();
			std::cout << "Data has been written to the file." << std::endl;
		}

		


		// Render here
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		glEnable(GL_DEPTH_TEST);
		//drawAxis1(0.3f, object.groups[0].rotate_matrix);
		
		drawAxis(0.3f);
		//std::cout << getRotationAngleZ(object.groups[0].rotate_matrix) << std::endl;;
		// Enable wireframe mode
		glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
		glMatrixMode(GL_MODELVIEW);
		glLoadIdentity();

		mat = Eigen::Matrix4f::Identity();
		mat.block<3, 3>(0, 0) = rotation.toRotationMatrix();
		glMultMatrixf(mat.data());


		// Draw vertices
	
		glPointSize(5.0f);

		
		glColor3f(1.0f, 1.0f, 1.0f);
		glBegin(GL_POINTS);
		for (int groupIdx = 0; groupIdx < groupNum; ++groupIdx) {
			Group& group = object.getGroup(groupIdx);
			std::vector<Vertex*> uniqueVertices = group.getUniqueVertices();
			for (Vertex* vertex : uniqueVertices) {
				glVertex3f(vertex->x, vertex->y, vertex->z);


			}
		}
		glEnd();


		for (int groupIdx = 0; groupIdx < groupNum; ++groupIdx) { 
			Group& group = object.getGroup(groupIdx);

			//ｻｭｲｻﾖﾘｸｴｵﾄｰ豎ｾ
			//std::vector<Vertex*> uniqueVertices = group.getUniqueVertices();
			//for (size_t i = 0; i < uniqueVertices.size(); ++i) {
			//	Vertex* vertex = uniqueVertices[i];
			//	char buffer[5]; m
			//	sprintf_s(buffer, "%d", vertex->index); // ｽｫintﾗｪｻｻﾎｪchar*
			//	glColor3f(1, 0.0f, 0.0f);
			//	glRasterPos3f(vertex->x, vertex->y, vertex->z);
			//	XPrintString(buffer);
			//}


			


			//for (Tetrahedron* tetra : group.tetrahedra) { 
			//	for (int i = 0; i < 4; ++i) { 
			//		Vertex* vertex = tetra->vertices[i];
			//		char buffer[5]; 
			//		sprintf_s(buffer, "%d", vertex->index); // ｽｫintﾗｪｻｻﾎｪchar*
			//		//if (groupIdx == 0) {
			//		//	glColor3f(1, 0.0f, 0.0f);
			//		//	glRasterPos3f(vertex->x, vertex->y, vertex->z);
			//		//	XPrintString(buffer);
			//		//}
			//			
			//		//if(groupIdx == 1)
			//		//{
			//		//	glColor3f(0, 1, 0.0f);
			//		//	glRasterPos3f(vertex->x, vertex->y, vertex->z);
			//		//	XPrintString(buffer);
			//		//}
			//		//	

			//		//std::default_random_engine generator(vertex->index);
			//		//std::uniform_real_distribution<float> distribution(0, 0.05);
			//		//float random_number = distribution(generator);
			//		glColor3f(1, 0.0f, 0.0f);
			//		glRasterPos3f(vertex->x + 0, vertex->y + 0, vertex->z + 0);
			//		XPrintString(buffer);
			//		
			//	}
			//}

		}
		//for (int groupIdx = 0; groupIdx < groupNum; ++groupIdx) {
		//	Group& group = object.getGroup(groupIdx);

		//	
		//	Eigen::Vector3f& center = group.centerofMass;

		//	
		//	char groupNumber[10];
		//	sprintf_s(groupNumber, "%d", groupIdx);

		//	
		//	glColor3f(1.0f, 1.0f, 0.0f);

		//	
		//	glRasterPos3f(center[0] + 1, center[1], center[2]);
		//	XPrintString(groupNumber);

		//	
		//}
		glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

		glBegin(GL_TRIANGLES);
		for (int groupIdx = 0; groupIdx < groupNum; ++groupIdx) {
			Group& group = object.getGroup(groupIdx);
			for (Tetrahedron* tet : group.tetrahedra) {
				Vertex* vertex0 = tet->vertices[0];
				Vertex* vertex1 = tet->vertices[1];
				Vertex* vertex2 = tet->vertices[2];
				Vertex* vertex3 = tet->vertices[3];

				// 使用HSV转换为RGB创建每个组的唯一颜色
				float hue = (360.0f * groupIdx) / groupNum;
				float saturation = 1.0f;
				float value = 1.0f;

				// 转换HSV为RGB
				float red, green, blue;
				hsvToRgb(hue, saturation, value, red, green, blue);

				// 设置颜色并绘制四个三角形面
				glColor3f(red, green, blue);
				glVertex3f(vertex0->x, vertex0->y, vertex0->z);
				glVertex3f(vertex1->x, vertex1->y, vertex1->z);
				glVertex3f(vertex2->x, vertex2->y, vertex2->z);

				glVertex3f(vertex0->x, vertex0->y, vertex0->z);
				glVertex3f(vertex1->x, vertex1->y, vertex1->z);
				glVertex3f(vertex3->x, vertex3->y, vertex3->z);

				glVertex3f(vertex0->x, vertex0->y, vertex0->z);
				glVertex3f(vertex2->x, vertex2->y, vertex2->z);
				glVertex3f(vertex3->x, vertex3->y, vertex3->z);

				glVertex3f(vertex1->x, vertex1->y, vertex1->z);
				glVertex3f(vertex2->x, vertex2->y, vertex2->z);
				glVertex3f(vertex3->x, vertex3->y, vertex3->z);
			}
		}


		// 恢复线框模式
		//glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);




		glEnd();
		// Draw edges
		glLineWidth(2.5f);  // 设置线宽为 3.0
		glBegin(GL_LINES);

		for (int groupIdx = 0; groupIdx < groupNum; ++groupIdx) {
			//float hhh;
			Group& group = object.getGroup(groupIdx);
			for (Tetrahedron* tet : group.tetrahedra) {
				for (int edgeIdx = 0; edgeIdx < 6; ++edgeIdx) {  // Loop through each edge in the tetrahedron
					Edge* edge = tet->edges[edgeIdx];
					Vertex* vertex1 = edge->vertices[0];
					Vertex* vertex2 = edge->vertices[1];
					bool isSurfaceEdge = edge->isBoundary;

					//Use HSV to RGB conversion to create a unique color for each group
					float hue = (360.0f * groupIdx) / groupNum;  // Distribute hues evenly across the spectrum
					//hhh = hue;
					float saturation = 1.0f;  // Full saturation
					float value = 1.0f;      // Full brightness

					//Convert HSV to RGB
					float red, green, blue;
					hsvToRgb(hue, saturation, value, red, green, blue);

					// If it's a boundary edge, you may want to adjust the color or keep as is
					// For example, make the color brighter if it's a boundary edge
					if (isSurfaceEdge == false) {
						/*red = std::min(1.0f, red);
						green = std::min(1.0f, green);
						blue = std::min(1.0f, blue);*/
						red = std::min(1.0f, red + 0.3f);
						green = std::min(1.0f, green + 0.3f);
						blue = std::min(1.0f, blue + 0.3f);
						float darkenFactor = 0.75f; // 调整这个系数以控制颜色深浅
						red *= darkenFactor;
						green *= darkenFactor;
						blue *= darkenFactor;

						drawEdge(vertex1, vertex2, red, green, blue);
					}

					
				}
			}
		}
		glEnd();

		
		//saveOBJ("43224.obj", object.groups);

		glPopMatrix();

		// Swap front and back buffers
		glfwSwapBuffers(window);

		// Poll for and process events
		glfwPollEvents();

		//calculate frame rate
		double currentTime = glfwGetTime();
		nbFrames++;
		if (currentTime - lastTime >= 1.0) { 
			printf("%d frames/sec\n", nbFrames);
			nbFrames = 0;
			lastTime += 1.0;
		}
		//printf("%d frame number\n", frame);
		frame++;
		//object.writeVerticesToFile("ourMethodResult.txt");
		/*object.bodyVolume = 0.0f;
		for (int i = 0; i < groupNum; i++)
		{
			object.groups[i].groupVolume = 0.0f;
		}
		for (int i = 0; i < groupNum; i++)
		{
			for (auto tets : object.groups[i].tetrahedra)
			{
				object.groups[i].groupVolume += tets->calVolumeTetra();
			}
			object.bodyVolume += object.groups[i].groupVolume;
		}*/
		
		//std::cout << object.bodyVolume << std::endl;
		
	
		/*double totalKE = 0.0;
		for (int i = 0; i < objectUniqueVertices.size(); i++) {
			double speedSquared = objectUniqueVertices[i]->velx * objectUniqueVertices[i]->velx + objectUniqueVertices[i]->vely * objectUniqueVertices[i]->vely + objectUniqueVertices[i]->velz * objectUniqueVertices[i]->velz;
			double kineticEnergy = 0.5 * objectUniqueVertices[i]->vertexMass * speedSquared;
			totalKE += kineticEnergy;
		}*/
		//double totalMass = 0.0;
		//double centerX = 0.0;
		//double centerY = 0.0;
		//double centerZ = 0.0;

		//for (int i = 0; i < objectUniqueVertices.size(); i++) {
		//	double vertexMass = objectUniqueVertices[i]->vertexMass;
		//	double vertexX = objectUniqueVertices[i]->x;
		//	double vertexY = objectUniqueVertices[i]->y;
		//	double vertexZ = objectUniqueVertices[i]->z;

		//	totalMass += vertexMass;
		//	centerX += vertexX * vertexMass;
		//	centerY += vertexY * vertexMass;
		//	centerZ += vertexZ * vertexMass;
		//}

		//if (totalMass != 0) {
		//	centerX /= totalMass;
		//	centerY /= totalMass;
		//	centerZ /= totalMass;
		//}
		//else {
		//	// Handle the case where totalMass is 0 to avoid division by zero
		//	centerX = 0.0;
		//	centerY = 0.0;
		//	centerZ = 0.0;
		//}

		// Output the center of mass
		//std::cout << "Center of Mass: (" << centerX << ", " << centerY << ", " << centerZ << ")" << std::endl;

	}
	
	
	glfwTerminate();
	return 0;
}
