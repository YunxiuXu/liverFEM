
//#define EIGEN_USE_MKL_ALL
#include <iostream>
#include <vector>
#include <algorithm>
#include <cstring>  // for std::strcpy
#include "tetgen.h"  // Include the TetGen header file
#include <fstream>
#include <unordered_map>
#include <unordered_set>
#include <limits>
#include "GL/glew.h" 
#include "GLFW/glfw3.h"
#include "params.h"
#include <cmath>
#include <random>
#include <omp.h>
#include "VisualOpenGL.h"
#include "SimpleUI.h"
#include "ReadSTL.h"
#include "Object.h"
#include "Vertex.h"
#include "Edge.h"



//C:/Users/xu_yu/Desktop/tmp/arial.ttf
 
// Global variables

// Force recording variables
bool isRecordingForce = false;
std::vector<float> recordedForces;
std::vector<float> recordedTime;
		double recordStartTime = 0.0;
		// Auto-Test Variables
		bool isAutoTestActive = false;
		int autoTestAxis = 0; // 0:X, 1:Y
		double autoTestStartTime = 0.0;
		const double autoTestDuration = 2.0;
		const float autoTestDistance = 0.5f;
		Vertex* g_selectedVertex = nullptr;
		Eigen::Vector3f autoTestStartPos;

void saveForceData(const std::string& filename) {
	std::ofstream file(filename);
	if (!file.is_open()) {
		std::cerr << "Failed to open force data file.\n";
		return;
	}
	file << "Time(s) ForceMagnitude\n";
	for (size_t i = 0; i < recordedForces.size(); ++i) {
		file << recordedTime[i] << " " << recordedForces[i] << "\n";
	}
	file.close();
	std::cout << "Force data saved to " << filename << " (" << recordedForces.size() << " samples)\n";
}

void saveOBJ(const std::string& filename, std::vector<Group>& groups) {
	std::ofstream objFile(filename);
	if (!objFile.is_open()) {
		std::cerr << "Failed to open file for writing.\n";
		return;
	}

	std::unordered_map<Vertex*, int> vertexIndexMap;
	int currentIndex = 1;

	// 遍历组，找出所有边界边并记录其顶点
	for (const auto& group : groups) {
		for (const auto* tet : group.tetrahedra) {
			for (const auto* edge : tet->edges) {
				if (edge->isBoundary) {
					for (Vertex* vertex : edge->vertices) {
						if (vertexIndexMap.find(vertex) == vertexIndexMap.end()) {
							vertexIndexMap[vertex] = currentIndex++;
							objFile << "v " << vertex->x << " " << vertex->y << " " << vertex->z << "\n";
						}
					}
				}
			}
		}
	}

	// 再次遍历，这次是为了构建面
	for (const auto& group : groups) {
		for (const auto* tet : group.tetrahedra) {
			for (const auto* edge : tet->edges) {
				if (edge->isBoundary) {
					objFile << "f";
					for (Vertex* vertex : edge->vertices) {
						objFile << " " << vertexIndexMap[vertex];
					}
					objFile << "\n";
				}
			}
		}
	}

	objFile.close();
	std::cout << "OBJ file saved: " << filename << "\n";
}
void writeOBJ(const Object& object, const std::string& filename) {
	std::ofstream file(filename);
	if (!file.is_open()) {
		std::cerr << "Failed to open file for writing.\n";
		return;
	}

	int vertexIndexOffset = 1;
	std::unordered_map<Vertex*, int> vertexIndexMap;

	for (const auto& group : object.groups) {
		for (const auto& tetrahedron : group.tetrahedra) {
			// vertex
			for (int i = 0; i < 4; ++i) {
				Vertex* vertex = tetrahedron->vertices[i];
				if (vertexIndexMap.find(vertex) == vertexIndexMap.end()) {
					vertexIndexMap[vertex] = vertexIndexOffset++;
					file << "v " << vertex->x << " " << vertex->y << " " << vertex->z << "\n";
				}
			}

			// writing faces
			// indices of four faces
			int indices[4][3] = { {0, 1, 2}, {0, 1, 3}, {1, 2, 3}, {0, 2, 3} };
			for (int i = 0; i < 4; ++i) {
				file << "f";
				for (int j = 0; j < 3; ++j) {
					file << " " << vertexIndexMap[tetrahedron->vertices[indices[i][j]]];
				}
				file << "\n";
			}
		}
	}

	file.close();
	std::cout << "OBJ file has been written.\n";
}
void writeSTL(const Object& object, const std::string& filename) {
	std::ofstream file(filename, std::ios::binary);
	if (!file.is_open()) {
		std::cerr << "Failed to open file for writing.\n";
		return;
	}

	// Write 80-byte header
	char header[80];
	memset(header, 0, sizeof(header)); // Fill header with zeros
	std::string description = "Binary STL generated by writeSTL function";
	std::memcpy(header, description.c_str(), std::min(description.size(), sizeof(header)));
	file.write(header, sizeof(header));

	// Count total number of triangles
	uint32_t totalTriangles = 0;
	for (const auto& group : object.groups) {
		totalTriangles += static_cast<uint32_t>(group.tetrahedra.size()) * 4u; // 4 faces per tetrahedron
	}
	file.write(reinterpret_cast<char*>(&totalTriangles), sizeof(totalTriangles));

	// Write triangles
	for (const auto& group : object.groups) {
		for (const auto& tetrahedron : group.tetrahedra) {
			// Indices for the four triangular faces of a tetrahedron
			int indices[4][3] = { {0, 1, 2}, {0, 1, 3}, {1, 2, 3}, {0, 2, 3} };

			for (int i = 0; i < 4; ++i) {
				// Write normal vector (defaulting to 0,0,0)
				float normal[3] = { 0.0f, 0.0f, 0.0f };
				file.write(reinterpret_cast<char*>(normal), sizeof(normal));

				// Write vertices of the triangle
				for (int j = 0; j < 3; ++j) {
					Vertex* vertex = tetrahedron->vertices[indices[i][j]];
					float vertexCoords[3] = { static_cast<float>(vertex->x),
											 static_cast<float>(vertex->y),
											 static_cast<float>(vertex->z) };
					file.write(reinterpret_cast<char*>(vertexCoords), sizeof(vertexCoords));
				}

				// Write attribute byte count (2 bytes, set to 0)
				uint16_t attributeByteCount = 0;
				file.write(reinterpret_cast<char*>(&attributeByteCount), sizeof(attributeByteCount));
			}
		}
	}

	file.close();
	std::cout << "Binary STL file has been written.\n";
}
void findTopAndBottomVertices(const std::vector<Group>& groups, std::vector<int>& topVertexLocalIndices, std::vector<int>& bottomVertexLocalIndices) {
	for (const Group& g : groups) {
		for (const auto& vertexPair : g.verticesMap) {
			Vertex* vertex = vertexPair.second;
			if (vertex->inity > 0.53) {
				topVertexLocalIndices.push_back(vertex->index);
			}
			if (vertex->inity < -0.53) {
				bottomVertexLocalIndices.push_back(vertex->index);
			}
		}
	}
}
void findMaxAndMinYVertices(const std::vector<Group>& groups, int& maxYVertexIndex, int& minYVertexIndex) {
	bool isFirstVertex = true;
	double maxY = 0.0;
	double minY = 0.0;

	for (const Group& g : groups) {
		for (const auto& vertexPair : g.verticesMap) {
			Vertex* vertex = vertexPair.second;

			if (isFirstVertex) {
				// Initialize maxY and minY with the first vertex's y-coordinate
				maxY = minY = vertex->inity;
				maxYVertexIndex = minYVertexIndex = vertex->index;
				isFirstVertex = false;
			}
			else {
				if (vertex->inity > maxY) {
					maxY = vertex->inity;
					maxYVertexIndex = vertex->index;
				}
				if (vertex->inity < minY) {
					minY = vertex->inity;
					minYVertexIndex = vertex->index;
				}
			}
		}
	}
}

void findUpperAndLowerVertices(const std::vector<Group>& groups, std::vector<int>& upperVertices, std::vector<int>& lowerVertices) {
	double sumInity = 0.0;
	int count = 0;

	// First pass: calculate the average inity
	for (const Group& g : groups) {
		for (const auto& vertexPair : g.verticesMap) {
			Vertex* vertex = vertexPair.second;
			sumInity += vertex->inity;
			count++;
		}
	}

	double averageInity = sumInity / count;

	// Second pass: classify vertices based on average inity
	for (const Group& g : groups) {
		for (const auto& vertexPair : g.verticesMap) {
			Vertex* vertex = vertexPair.second;
			if (vertex->inity > averageInity) {
				upperVertices.push_back(vertex->index);
			}
			else {
				lowerVertices.push_back(vertex->index);
			}
		}
	}
}

struct DragState {
	bool active = false;
	Vertex* target = nullptr;
	double lastX = 0.0;
	double lastY = 0.0;
	float grabbedNdcZ = 0.0f;
	Eigen::Vector3f grabOffset = Eigen::Vector3f::Zero(); // targetPos - cursorWorldPos (prevents jump)
};

Eigen::Vector2f projectToScreen(const Eigen::Vector3f& pos,
	const Eigen::Matrix4f& model,
	const Eigen::Matrix4f& projection,
	int width,
	int height) {
	Eigen::Vector4f clip = projection * model * Eigen::Vector4f(pos.x(), pos.y(), pos.z(), 1.0f);
	Eigen::Vector3f ndc = clip.head<3>() / clip.w();
	float sx = (ndc.x() * 0.5f + 0.5f) * static_cast<float>(width);
	float sy = (1.0f - (ndc.y() * 0.5f + 0.5f)) * static_cast<float>(height);
	return Eigen::Vector2f(sx, sy);
}

Vertex* pickVertexAtCursor(const std::vector<Vertex*>& vertices,
	double mouseX,
	double mouseY,
	const Eigen::Matrix4f& model,
	const Eigen::Matrix4f& projection,
	int width,
	int height,
	float maxScreenDistance = 60.0f) {
	float bestDist2 = std::numeric_limits<float>::max();
	Vertex* bestVertex = nullptr;

	for (const auto* vertex : vertices) {
		Eigen::Vector2f screenPos = projectToScreen(Eigen::Vector3f(vertex->x, vertex->y, vertex->z), model, projection, width, height);
		float dx = static_cast<float>(mouseX) - screenPos.x();
		float dy = static_cast<float>(mouseY) - screenPos.y();
		float dist2 = dx * dx + dy * dy;
		if (dist2 < bestDist2) {
			bestDist2 = dist2;
			bestVertex = const_cast<Vertex*>(vertex);
		}
	}

	if (bestVertex && bestDist2 <= maxScreenDistance * maxScreenDistance) {
		return bestVertex;
	}
	return nullptr;
}

static Eigen::Vector3f unprojectCursorToWorld(double fbMouseX,
	double fbMouseY,
	float ndcZ,
	const Eigen::Matrix4f& invProjectionModel,
	int width,
	int height) {
	const float safeW = static_cast<float>(width ? width : 1);
	const float safeH = static_cast<float>(height ? height : 1);
	const float ndcX = static_cast<float>(fbMouseX) / safeW * 2.0f - 1.0f;
	const float ndcY = 1.0f - static_cast<float>(fbMouseY) / safeH * 2.0f;

	Eigen::Vector4f clip(ndcX, ndcY, ndcZ, 1.0f);
	Eigen::Vector4f world = invProjectionModel * clip;
	const float invW = (std::abs(world.w()) > 1e-8f) ? (1.0f / world.w()) : 1.0f;
	return world.head<3>() * invW;
}

int main() {

	loadParams("parameters.txt");
	// Make sure both OpenMP and Eigen use all available cores
	omp_set_dynamic(0);
	omp_set_num_threads(omp_get_max_threads());
	Eigen::initParallel();
	Eigen::setNbThreads(omp_get_max_threads());

	tetgenio in, out;
	in.firstnumber = 1;  // All indices start from 1
	
	if (useDirectLoading) {
		// Direct loading mode: load node and element files without meshing
		std::cout << "Using direct loading mode with node file: " << nodeFile << " and element file: " << eleFile << std::endl;
		
		// Extract base filename without extension for TetGen (it will append .node and .ele automatically)
		std::string nodeFileBase = nodeFile;
		size_t nodeExtPos = nodeFileBase.find_last_of('.');
		if (nodeExtPos != std::string::npos) {
			nodeFileBase = nodeFileBase.substr(0, nodeExtPos);
		}
		
		std::string eleFileBase = eleFile;
		size_t eleExtPos = eleFileBase.find_last_of('.');
		if (eleExtPos != std::string::npos) {
			eleFileBase = eleFileBase.substr(0, eleExtPos);
		}
		
		char* nodeFileC = const_cast<char*>(nodeFileBase.c_str());
		char* eleFileC = const_cast<char*>(eleFileBase.c_str());
		
		std::cout << "Loading base filename: " << nodeFileBase << " (TetGen will append .node/.ele)" << std::endl;
		
		if (!in.load_node(nodeFileC)) {
			std::cerr << "Error loading .node file: " << nodeFileBase << ".node" << std::endl;
			return 1;
		}
		
		if (!in.load_tet(eleFileC)) {
			std::cerr << "Error loading .ele file: " << eleFileBase << ".ele" << std::endl;
			return 1;
		}
		
		// Copy input directly to output without meshing
		out = in;
	} else {
		// STL meshing mode: load STL file and use TetGen for meshing
		std::cout << "Using STL meshing mode with file: " << stlFile << std::endl;
		
		readSTL(stlFile.c_str(), in);
		
		// Configure TetGen behavior
		tetgenbehavior behavior;
		char* args = const_cast<char*>(tetgenArgs.c_str());
		behavior.parse_commandline(args);
		
		// Call TetGen to tetrahedralize the geometry
		tetrahedralize(&behavior, &in, &out);
	}
	



	Object object;
	groupNum = groupNumX * groupNumY * groupNumZ;
	object.groupNum = groupNum;
	object.groupNumX = groupNumX;
	object.groupNumY = groupNumY;
	object.groupNumZ = groupNumZ;
	divideIntoGroups(out, object, groupNumX, groupNumY, groupNumZ); //convert tetgen to our data structure

	/*out.save_nodes("vbdbeam");
	out.save_elements("vbdbeam");*/
	//writeSTL(object, "vbdbeam.stl");
	//writeOBJ(object, "vbdbeam.obj");


	object.updateIndices(); 
	object.assignLocalIndicesToAllGroups(); 
	object.generateUniqueVertices();
	
	object.updateAdjacentGroupIndices(groupNumX, groupNumY, groupNumZ);
	for (int i = 0; i < groupNum; ++i) {
	
		object.storeAdjacentGroupsCommonVertices(i);
	}
	
	// Accessing and printing the groups and their tetrahedra
//#pragma omp parallel for
	int nonEmptyGroupCount = 0;
	for (int i = 0; i < groupNum; ++i) {  // Loop over the groups
		Group& group = object.getGroup(i);
		group.LHS_I = Eigen::MatrixXf::Identity(3 * group.verticesMap.size(), 3 * group.verticesMap.size()); //ｽﾚﾊ｡ﾊｱｼ菻｡ﾄﾜﾊﾖ
		if (group.tetrahedra.empty()) {
			continue; // Skip noisy logging for empty groups
		}
		++nonEmptyGroupCount;
		std::cout << "Group " << i << " has " << group.tetrahedra.size() << " tetrahedra." << std::endl;
	}
	std::cout << "Non-empty groups: " << nonEmptyGroupCount << "/" << groupNum << std::endl;


	// Initialize the GLFW library
	if (!glfwInit()) {
		return -1;
	}

	// Create a windowed mode window and its OpenGL context
	GLFWwindow* window = glfwCreateWindow(1080, 1080, "Tetrahedral Mesh Visualization", NULL, NULL);
	if (!window) {
		glfwTerminate();
		return -1;
	}

	// Make the window's context current
	glfwMakeContextCurrent(window);
	// Set scroll callback
	glfwSetScrollCallback(window, scroll_callback);
	glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
	glfwSetMouseButtonCallback(window, mouseButtonCallback);
	glfwSetCursorPosCallback(window, cursorPosCallback);
	int fbWidth = 0;
	int fbHeight = 0;
	glfwGetFramebufferSize(window, &fbWidth, &fbHeight);
	framebuffer_size_callback(window, fbWidth, fbHeight);
	applyProjectionMatrix();

	Eigen::Matrix4f mat;
	initFontData();
	//object.findCommonVertices();
	//object.commonPoints = object.findCommonVertices1(object.groups[0], object.groups[1]);
	//object.commonPoints1 = object.findCommonVertices1(object.groups[1], object.groups[2]);
	//object.commonPoints2 = object.findCommonVertices1(object.groups[2], object.groups[3]);
	//object.commonPoints3 = object.findCommonVertices1(object.groups[3], object.groups[4]);
	//std::pair<std::vector<Vertex*>, std::vector<Vertex*>> commonVertices2 = object.findCommonVertices1(object.groups[0], object.groups[1]);
	// 在肝门区域使用球形区域进行固定：取背面一定厚度的质心作为中心
	std::unordered_set<Vertex*> visitedVertices;
	std::vector<Vertex*> uniqueVertices;
	for (const auto& g : object.groups) {
		for (const auto& pair : g.verticesMap) {
			Vertex* v = pair.second;
			if (visitedVertices.insert(v).second) {
				uniqueVertices.push_back(v);
			}
		}
	}

	if (!uniqueVertices.empty()) {
		Eigen::Vector3f minBound(
			std::numeric_limits<float>::max(),
			std::numeric_limits<float>::max(),
			std::numeric_limits<float>::max());
		Eigen::Vector3f maxBound(
			-std::numeric_limits<float>::max(),
			-std::numeric_limits<float>::max(),
			-std::numeric_limits<float>::max());

		for (const auto* v : uniqueVertices) {
			minBound.x() = std::min(minBound.x(), v->initx);
			minBound.y() = std::min(minBound.y(), v->inity);
			minBound.z() = std::min(minBound.z(), v->initz);
			maxBound.x() = std::max(maxBound.x(), v->initx);
			maxBound.y() = std::max(maxBound.y(), v->inity);
			maxBound.z() = std::max(maxBound.z(), v->initz);
		}

		const float depth = maxBound.z() - minBound.z();
		const float backSliceZ = minBound.z() + depth * 0.12f; // 取最靠背面 12% 的区域
		Eigen::Vector3f backCentroid(0.0f, 0.0f, 0.0f);
		int backCount = 0;
		for (const auto* v : uniqueVertices) {
			if (v->initz <= backSliceZ) {
				backCentroid.x() += v->initx;
				backCentroid.y() += v->inity;
				backCentroid.z() += v->initz;
				++backCount;
			}
		}

		if (backCount > 0) {
			backCentroid /= static_cast<float>(backCount);
		}
		else {
			backCentroid = Eigen::Vector3f(
				0.5f * (minBound.x() + maxBound.x()),
				0.5f * (minBound.y() + maxBound.y()),
				minBound.z());
		}

		// 稍微往内部推一点，避免只作用在表面三角面
		backCentroid.z() = std::min(backCentroid.z() + depth * 0.02f, maxBound.z());

		const float anchorRadius = std::max(depth * 0.2f, 0.001f);
		object.fixRegion(backCentroid, anchorRadius);
	} else {
		std::cout << "No vertices collected for fixing region." << std::endl;
	}
	
	std::vector<int> topVertexLocalIndices;
	std::vector<int> bottomVertexLocalIndices;

	findTopAndBottomVertices(object.groups, topVertexLocalIndices, bottomVertexLocalIndices);
	int maxYIndex, minYIndex;
	findMaxAndMinYVertices(object.groups, maxYIndex, minYIndex);


	// Now topVertexLocalIndices and bottomVertexLocalIndices contain the local indices of the top and bottom vertices, respectively.

	
	//Fix by several vertices
	//float maxY = -std::numeric_limits<float>::infinity();
	//Vertex* vertexWithMaxY = nullptr;
	
	//for (Group& g : object.groups) {
	//	for (const auto& vertexPair : g.verticesMap) {
	//		Vertex* vertex = vertexPair.second;
	//		if (vertex->y > maxY) {
	//			maxY = vertex->y;
	//			vertexWithMaxY = vertex;
	//		}
	//	}
	//}
	
	//if (vertexWithMaxY != nullptr) {
	//	vertexWithMaxY->isFixed = true;
	//	
	//}
	/////////
	
#pragma omp parallel for
	for (int i = 0; i < object.groupNum; ++i) {
		object.groups[i].calMassMatrix(density);
		object.groups[i].calDampingMatrix();
		object.groups[i].calCenterofMass();
		object.groups[i].calInitCOM();//initial com
		object.groups[i].calLocalPos(); // initial local positions
		
		// Check if anisotropic parameters are used (youngs1 != youngs2)
		// Assuming youngs1, youngs2, youngs3 are global variables from params.h
		if (std::abs(youngs1 - youngs2) > 1e-1f || std::abs(youngs1 - youngs3) > 1e-1f) {
			object.groups[i].calGroupKAni(youngs1, youngs2, youngs3, poisson);
			if (i == 0) std::cout << "Using Anisotropic Stiffness Matrix (E1=" << youngs1 << ", E2=" << youngs2 << ", E3=" << youngs3 << ")\n";
		} else {
			object.groups[i].calGroupK(youngs, poisson);
			if (i == 0) std::cout << "Using Isotropic Stiffness Matrix (E=" << youngs << ")\n";
		}
		
		object.groups[i].setVertexMassesFromMassMatrix();//vertex mass
		object.groups[i].calMassGroup();
		object.groups[i].calMassDistributionMatrix();
		//object.groups[i].inverseTerm = (object.groups[i].massMatrix + object.groups[i].dampingMatrix * 0.01f).inverse(); 
		//object.groups[i].inverseTermSparse = object.groups[i].inverseTerm.sparseView();
		object.groups[i].calLHS();
	}

	//for calculate frame rate
	double lastTime = glfwGetTime();
	int nbFrames = 0;
	glfwSwapInterval(0);


	//------------------- save coordinates
	std::vector<Vertex*> objectUniqueVertices;

	for (int groupIdx = 0; groupIdx < groupNum; ++groupIdx) {
		Group& group = object.getGroup(groupIdx);
		auto& verticesMap = group.verticesMap; 

	for (const auto& pair : verticesMap) {
			bool found = false;
			for (const auto& vertex : objectUniqueVertices) {
				if (vertex->x == pair.second->initx && vertex->inity == pair.second->inity && vertex->initz == pair.second->initz) {
					found = true;
					break;
				}
			}
			if (!found) {
				objectUniqueVertices.push_back(pair.second);
			}
		}
	}

	std::sort(objectUniqueVertices.begin(), objectUniqueVertices.end(), [](const Vertex* a, const Vertex* b) {
		return a->index < b->index;
		});//index from min to max

	DragState dragState;

	int frame = 1;
	SimpleUI::Context ui;
	while (!glfwWindowShouldClose(window)) {
		ui.beginFrame(window);

		//object.commonPoints1 = object.findCommonVertices(object.groups[1], object.groups[2]);
		// ------------------ UI layout (window coordinates, origin at top-left)
		const float uiMargin = 12.0f;
		const float uiPanelW = 280.0f;
		const float uiPanelH = 240.0f;
		const SimpleUI::Rect uiPanelRect{ uiMargin, uiMargin, uiPanelW, uiPanelH };

		const float innerPad = 12.0f;
		const float gap = 8.0f;
		const float buttonH = 34.0f;
		const float innerX = uiPanelRect.x + innerPad;
		const float innerY = uiPanelRect.y + innerPad;
		const float innerW = uiPanelRect.w - innerPad * 2.0f;

		const float colW = (innerW - gap) * 0.5f;

		const SimpleUI::Rect uiRecRect{ innerX, innerY, colW, buttonH };
		const SimpleUI::Rect uiStopRect{ innerX + colW + gap, innerY, colW, buttonH };
		const SimpleUI::Rect uiAutoXRect{ innerX, innerY + (buttonH + gap), colW, buttonH };
		const SimpleUI::Rect uiAutoYRect{ innerX + colW + gap, innerY + (buttonH + gap), colW, buttonH };
		const SimpleUI::Rect uiSaveRect{ innerX, innerY + 2.0f * (buttonH + gap), innerW, buttonH };

		const float dpadTop = innerY + 3.0f * (buttonH + gap);
		const float dpadCell = 34.0f;
		const float dpadGap = 6.0f;
		const float dpadW = dpadCell * 3.0f + dpadGap * 2.0f;
		const float dpadX = innerX + (innerW - dpadW) * 0.5f;
		const float dpadY = dpadTop;

		const SimpleUI::Rect uiUpRect{ dpadX + (dpadCell + dpadGap), dpadY, dpadCell, dpadCell };
		const SimpleUI::Rect uiLeftRect{ dpadX, dpadY + (dpadCell + dpadGap), dpadCell, dpadCell };
		const SimpleUI::Rect uiRightRect{ dpadX + 2.0f * (dpadCell + dpadGap), dpadY + (dpadCell + dpadGap), dpadCell, dpadCell };
		const SimpleUI::Rect uiDownRect{ dpadX + (dpadCell + dpadGap), dpadY + 2.0f * (dpadCell + dpadGap), dpadCell, dpadCell };

		const bool uiStartRecClicked = ui.clicked(uiRecRect);
		const bool uiStopRecClicked = ui.clicked(uiStopRect);
		const bool uiAutoXClicked = ui.clicked(uiAutoXRect, (!isAutoTestActive && g_selectedVertex != nullptr));
		const bool uiAutoYClicked = ui.clicked(uiAutoYRect, (!isAutoTestActive && g_selectedVertex != nullptr));
		const bool uiSaveClicked = ui.clicked(uiSaveRect);

		// ------------------ Force Recording Controls (keyboard + UI)
		static bool rPressed = false;
		static bool sPressed = false;
		if (((glfwGetKey(window, GLFW_KEY_R) == GLFW_PRESS && !rPressed)) || uiStartRecClicked) {
			isRecordingForce = true;
			recordedForces.clear();
			recordedTime.clear();
			recordStartTime = glfwGetTime();
			std::cout << ">>> Started recording force data..." << std::endl;
			rPressed = true;
		}
		if (glfwGetKey(window, GLFW_KEY_R) == GLFW_RELEASE) rPressed = false;

		if (((glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS && !sPressed)) || uiStopRecClicked) {
			if (isRecordingForce) {
				isRecordingForce = false;
				saveForceData("force_data.txt");
				std::cout << ">>> Stopped recording. Data saved." << std::endl;
			}
			sPressed = true;
		}
		if (glfwGetKey(window, GLFW_KEY_S) == GLFW_RELEASE) sPressed = false;

		static bool drawFaces = true;
		static bool drawEdges = true;
		// Keys for Auto-Test: X and Y.
		// Disabled Z/X display toggles to avoid conflict.

		if (((glfwGetKey(window, GLFW_KEY_X) == GLFW_PRESS) || uiAutoXClicked) && !isAutoTestActive && g_selectedVertex) {
			isAutoTestActive = true;
			autoTestAxis = 0; // X-axis
			autoTestStartTime = glfwGetTime();
			autoTestStartPos = Eigen::Vector3f(g_selectedVertex->x, g_selectedVertex->y, g_selectedVertex->z);
			
			dragState.active = true;
			dragState.target = g_selectedVertex;
			
			isRecordingForce = true;
			recordedForces.clear();
			recordedTime.clear();
			recordStartTime = glfwGetTime();
			
			std::cout << ">>> STARTING AUTO TEST (X-AXIS) on Vertex " << g_selectedVertex->index << std::endl;
		}

		if (((glfwGetKey(window, GLFW_KEY_Y) == GLFW_PRESS) || uiAutoYClicked) && !isAutoTestActive && g_selectedVertex) {
			isAutoTestActive = true;
			autoTestAxis = 1; // Y-axis
			autoTestStartTime = glfwGetTime();
			autoTestStartPos = Eigen::Vector3f(g_selectedVertex->x, g_selectedVertex->y, g_selectedVertex->z);
			
			dragState.active = true;
			dragState.target = g_selectedVertex;
			
			isRecordingForce = true;
			recordedForces.clear();
			recordedTime.clear();
			recordStartTime = glfwGetTime();
			
			std::cout << ">>> STARTING AUTO TEST (Y-AXIS) on Vertex " << g_selectedVertex->index << std::endl;
		}

		// Arrow keys apply a directional force to the whole object.
		const float arrowForceMagnitude = 50.0f;
		Eigen::Vector3f inputForce = Eigen::Vector3f::Zero();
		if (glfwGetKey(window, GLFW_KEY_UP) == GLFW_PRESS || ui.held(uiUpRect)) {
			inputForce.y() += arrowForceMagnitude;
		}
		if (glfwGetKey(window, GLFW_KEY_DOWN) == GLFW_PRESS || ui.held(uiDownRect)) {
			inputForce.y() -= arrowForceMagnitude;
		}
		if (glfwGetKey(window, GLFW_KEY_LEFT) == GLFW_PRESS || ui.held(uiLeftRect)) {
			inputForce.x() -= arrowForceMagnitude;
		}
		if (glfwGetKey(window, GLFW_KEY_RIGHT) == GLFW_PRESS || ui.held(uiRightRect)) {
			inputForce.x() += arrowForceMagnitude;
		}
		//std::cout << wKey << std::endl;
		//double aa = object.groups[0].tetrahedra[0]->calMassTetra(density);

		// Handle right-click dragging to apply a localized force.
		std::unordered_map<int, Eigen::Vector3f> dragForces;
		int windowWidth = 1;
		int windowHeight = 1;
		glfwGetFramebufferSize(window, &windowWidth, &windowHeight);
		int logicalWidth = 1;
		int logicalHeight = 1;
		glfwGetWindowSize(window, &logicalWidth, &logicalHeight);
		windowWidth = windowWidth == 0 ? 1 : windowWidth;
		windowHeight = windowHeight == 0 ? 1 : windowHeight;
		logicalWidth = logicalWidth == 0 ? 1 : logicalWidth;
		logicalHeight = logicalHeight == 0 ? 1 : logicalHeight;
		const double scaleX = static_cast<double>(windowWidth) / static_cast<double>(logicalWidth);
		const double scaleY = static_cast<double>(windowHeight) / static_cast<double>(logicalHeight);

		Eigen::Matrix4f modelMatrix = Eigen::Matrix4f::Identity();
		modelMatrix.block<3, 3>(0, 0) = rotation.toRotationMatrix();
		Eigen::Matrix4f projectionMatrix = buildProjectionMatrix();
		Eigen::Matrix4f projectionModel = projectionMatrix * modelMatrix;
		Eigen::Matrix4f invProjectionModel = projectionModel.inverse();

		static bool rightWasHeld = false;
		bool rightHeld = glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_RIGHT) == GLFW_PRESS;
		if (rightHeld && !rightWasHeld) {
			double mouseX = 0.0;
			double mouseY = 0.0;
			glfwGetCursorPos(window, &mouseX, &mouseY);
			double fbMouseX = mouseX * scaleX;
			double fbMouseY = mouseY * scaleY;
			Vertex* pickedVertex = pickVertexAtCursor(objectUniqueVertices, fbMouseX, fbMouseY, modelMatrix, projectionMatrix, windowWidth, windowHeight);
			if (pickedVertex != nullptr) {
				dragState.active = true;
				dragState.target = pickedVertex;
				g_selectedVertex = pickedVertex; // Save for auto-test
				
				dragState.lastX = fbMouseX;
				dragState.lastY = fbMouseY;
				Eigen::Vector3f targetPos(dragState.target->x, dragState.target->y, dragState.target->z);
				Eigen::Vector4f clip = projectionModel * Eigen::Vector4f(targetPos.x(), targetPos.y(), targetPos.z(), 1.0f);
				const float invW = (std::abs(clip.w()) > 1e-8f) ? (1.0f / clip.w()) : 1.0f;
				dragState.grabbedNdcZ = clip.z() * invW;
				Eigen::Vector3f cursorWorld = unprojectCursorToWorld(fbMouseX, fbMouseY, dragState.grabbedNdcZ, invProjectionModel, windowWidth, windowHeight);
				dragState.grabOffset = targetPos - cursorWorld;
				std::cout << "Picked vertex id " << pickedVertex->index 
					<< " at (" << pickedVertex->x << ", " << pickedVertex->y << ", " << pickedVertex->z << ")" << std::endl;
			}
			else {
				std::cout << "No vertex picked under cursor." << std::endl;
			}
		}
		else if (!rightHeld && !isAutoTestActive) {
			dragState.active = false;
			dragState.target = nullptr;
		}

		if (dragState.active && dragState.target != nullptr && (rightHeld || isAutoTestActive)) {
			Eigen::Vector3f desiredTargetPos;
			bool processPhysics = true;

			if (isAutoTestActive) {
				double elapsed = glfwGetTime() - autoTestStartTime;
				if (elapsed > autoTestDuration) {
					// End Auto Test
					isAutoTestActive = false;
					isRecordingForce = false;
					dragState.active = false;
					processPhysics = false;
					std::string fname = (autoTestAxis == 0) ? "force_data_x.txt" : "force_data_y.txt";
					saveForceData(fname);
					std::cout << ">>> Auto Test Finished. Saved to " << fname << std::endl;
				} else {
					// Interpolate
					float t = static_cast<float>(elapsed / autoTestDuration);
					desiredTargetPos = autoTestStartPos;
					if (autoTestAxis == 0) desiredTargetPos.x() += autoTestDistance * t; // X Axis
					else desiredTargetPos.y() += autoTestDistance * t; // Y Axis
				}
			} else {
				// Mouse Logic
				double mouseX = 0.0;
				double mouseY = 0.0;
				glfwGetCursorPos(window, &mouseX, &mouseY);
				double fbMouseX = mouseX * scaleX;
				double fbMouseY = mouseY * scaleY;
				Eigen::Vector3f cursorWorld = unprojectCursorToWorld(fbMouseX, fbMouseY, dragState.grabbedNdcZ, invProjectionModel, windowWidth, windowHeight);
				desiredTargetPos = cursorWorld + dragState.grabOffset;
			}

			if (processPhysics && dragState.active) {
				const float influenceRadius = dragInfluenceRadius;
				const float stiffness = dragStiffness; // Higher = stronger pull toward cursor.
				const float maxAccel = dragMaxAccel; // Clamp to avoid exploding forces.
				Eigen::Vector3f targetPos(dragState.target->x, dragState.target->y, dragState.target->z);
				Eigen::Vector3f displacement = desiredTargetPos - targetPos;
				float displacementNorm = displacement.norm();
				if (displacementNorm > 1e-6f) {
					float maxDisp = dragMaxDisplacement;
					if (displacementNorm > maxDisp) {
						displacement *= (maxDisp / displacementNorm);
						displacementNorm = maxDisp;
					}
				}
	
				float currentFrameTotalForce = 0.0f;
				for (Vertex* vertex : objectUniqueVertices) {
					Eigen::Vector3f currentPos(vertex->x, vertex->y, vertex->z);
					float dist = (currentPos - targetPos).norm();
					if (dist <= influenceRadius) {
						float falloff = std::max(0.05f, 1.0f - dist / influenceRadius); // keep a small minimum
						if (vertex == dragState.target) {
							falloff *= 1.5f; // slightly prioritize the grabbed vertex
						}
						Eigen::Vector3f accel = displacement * (stiffness * falloff);
						float accelNorm = accel.norm();
						if (accelNorm > maxAccel) {
							accel *= (maxAccel / accelNorm);
						}
						dragForces[vertex->index] = accel;
						currentFrameTotalForce += accel.norm(); // Approximate force magnitude (proportional to accel)
					}
				}
				
				if (isRecordingForce) {
					recordedForces.push_back(currentFrameTotalForce);
					recordedTime.push_back(glfwGetTime() - recordStartTime);
				}
			}
		}

		rightWasHeld = rightHeld;
#pragma omp parallel for
		for (int i = 0; i < groupNum; i++) {
			//object.groups[i].calGroupKFEM(youngs, poisson);
			object.groups[i].calPrimeVec(inputForce, dragForces);
			//object.groups[i].calPrimeVecS(topVertexLocalIndices, bottomVertexLocalIndices);
			//object.groups[i].calPrimeVec2(wKey);
			//object.groups[i].calPrimeVec(wKey);
			
			//object.groups[i].calPrimeVecT(wKey);
			/*object.groups[i].calLHSFEM();
			object.groups[i].calRHSFEM();
			object.groups[i].calDeltaXFEM();
			object.groups[i].calculateCurrentPositionsFEM();
			object.groups[i].updateVelocityFEM();
			object.groups[i].updatePositionFEM();*/

			object.groups[i].calRotationMatrix(frame);

		}
		/*for (int i = 0; i < groupNum; i++) {
			std::cout << "Group" << i << "Prime vector is" << std::endl << object.groups[i].primeVec;
		}*/


		object.PBDLOOP(10);

		static bool cPressed = false;
		const bool cKeyDown = glfwGetKey(window, GLFW_KEY_C) == GLFW_PRESS;
		const bool cTriggered = (cKeyDown && !cPressed) || uiSaveClicked;
		if (cTriggered) {
			std::ofstream file("vbdcomp_our.txt", std::ios::out | std::ios::trunc);
			if (!file.is_open()) {
				std::cerr << "Failed to open file." << std::endl;
				return 0;
			}
			for (int i = 0; i < objectUniqueVertices.size(); i++) {
				file << i + 1 << " " << objectUniqueVertices[i]->x << " " << objectUniqueVertices[i]->y << " " << objectUniqueVertices[i]->z << std::endl;
			}
			file.close();
			std::cout << "Data has been written to the file." << std::endl;
		}
		cPressed = cKeyDown;

		


		// Render here
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		glEnable(GL_DEPTH_TEST);
		//drawAxis1(0.3f, object.groups[0].rotate_matrix);
		
		drawAxis(0.3f);
		//std::cout << getRotationAngleZ(object.groups[0].rotate_matrix) << std::endl;;
		// Enable wireframe mode
		glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
		glMatrixMode(GL_MODELVIEW);
		glLoadIdentity();

		mat = Eigen::Matrix4f::Identity();
		mat.block<3, 3>(0, 0) = rotation.toRotationMatrix();
		glMultMatrixf(mat.data());


		// Draw vertices
	
		glPointSize(5.0f);

		
		glColor3f(1.0f, 1.0f, 1.0f);
		glBegin(GL_POINTS);
		for (int groupIdx = 0; groupIdx < groupNum; ++groupIdx) {
			Group& group = object.getGroup(groupIdx);
			std::vector<Vertex*> uniqueVertices = group.getUniqueVertices();
			for (Vertex* vertex : uniqueVertices) {
				glVertex3f(vertex->x, vertex->y, vertex->z);


			}
		}
		glEnd();

		// (Removed old debug text rendering code.)
		if (drawFaces) {
			glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
			glBegin(GL_TRIANGLES);
			for (int groupIdx = 0; groupIdx < groupNum; ++groupIdx) {
				Group& group = object.getGroup(groupIdx);
				for (Tetrahedron* tet : group.tetrahedra) {
					Vertex* vertex0 = tet->vertices[0];
					Vertex* vertex1 = tet->vertices[1];
					Vertex* vertex2 = tet->vertices[2];
					Vertex* vertex3 = tet->vertices[3];

					// 使用HSV转换为RGB创建每个组的唯一颜色
					float hue = (360.0f * groupIdx) / groupNum;
					float saturation = 1.0f;
					float value = 1.0f;

					// 转换HSV为RGB
					float red, green, blue;
					hsvToRgb(hue, saturation, value, red, green, blue);

					// 设置颜色并绘制四个三角形面
					glColor3f(red, green, blue);
					glVertex3f(vertex0->x, vertex0->y, vertex0->z);
					glVertex3f(vertex1->x, vertex1->y, vertex1->z);
					glVertex3f(vertex2->x, vertex2->y, vertex2->z);

					glVertex3f(vertex0->x, vertex0->y, vertex0->z);
					glVertex3f(vertex1->x, vertex1->y, vertex1->z);
					glVertex3f(vertex3->x, vertex3->y, vertex3->z);

					glVertex3f(vertex0->x, vertex0->y, vertex0->z);
					glVertex3f(vertex2->x, vertex2->y, vertex2->z);
					glVertex3f(vertex3->x, vertex3->y, vertex3->z);

					glVertex3f(vertex1->x, vertex1->y, vertex1->z);
					glVertex3f(vertex2->x, vertex2->y, vertex2->z);
					glVertex3f(vertex3->x, vertex3->y, vertex3->z);
				}
			}


		// 恢复线框模式
		//glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);




			glEnd();
		}
		// Draw edges
		if (drawEdges) {
			glLineWidth(2.5f);  // 设置线宽为 3.0
			glBegin(GL_LINES);

			for (int groupIdx = 0; groupIdx < groupNum; ++groupIdx) {
				//float hhh;
				Group& group = object.getGroup(groupIdx);
				for (Tetrahedron* tet : group.tetrahedra) {
					for (int edgeIdx = 0; edgeIdx < 6; ++edgeIdx) {  // Loop through each edge in the tetrahedron
						Edge* edge = tet->edges[edgeIdx];
						Vertex* vertex1 = edge->vertices[0];
						Vertex* vertex2 = edge->vertices[1];
						bool isSurfaceEdge = edge->isBoundary;

						//Use HSV to RGB conversion to create a unique color for each group
						float hue = (360.0f * groupIdx) / groupNum;  // Distribute hues evenly across the spectrum
						//hhh = hue;
						float saturation = 1.0f;  // Full saturation
						float value = 1.0f;      // Full brightness

						//Convert HSV to RGB
						float red, green, blue;
						hsvToRgb(hue, saturation, value, red, green, blue);

						// If it's a boundary edge, you may want to adjust the color or keep as is
						// For example, make the color brighter if it's a boundary edge
						if (isSurfaceEdge == false) {
							/*red = std::min(1.0f, red);
							green = std::min(1.0f, green);
							blue = std::min(1.0f, blue);*/
							red = std::min(1.0f, red + 0.3f);
							green = std::min(1.0f, green + 0.3f);
							blue = std::min(1.0f, blue + 0.3f);
							float darkenFactor = 0.75f; // 调整这个系数以控制颜色深浅
							red *= darkenFactor;
							green *= darkenFactor;
							blue *= darkenFactor;

							drawEdge(vertex1, vertex2, red, green, blue);
						}

						
					}
				}
			}
			glEnd();
		}

		
		//saveOBJ("43224.obj", object.groups);

		glPopMatrix();

		// ------------------ UI overlay (draw last)
		ui.beginDraw2D();
		ui.drawPanelBackground(uiPanelRect);
		ui.renderButton(uiRecRect, "REC");
		ui.renderButton(uiStopRect, "STOP", isRecordingForce);
		ui.renderButton(uiAutoXRect, "AUTO X", (!isAutoTestActive && g_selectedVertex != nullptr));
		ui.renderButton(uiAutoYRect, "AUTO Y", (!isAutoTestActive && g_selectedVertex != nullptr));
		ui.renderButton(uiSaveRect, "SAVE");
		ui.renderButton(uiUpRect, "U");
		ui.renderButton(uiLeftRect, "L");
		ui.renderButton(uiRightRect, "R");
		ui.renderButton(uiDownRect, "D");
		ui.endDraw2D();

		// Swap front and back buffers
		glfwSwapBuffers(window);

		// Poll for and process events
		glfwPollEvents();

		//calculate frame rate
		double currentTime = glfwGetTime();
		nbFrames++;
		if (currentTime - lastTime >= 1.0) { 
			printf("%d frames/sec\n", nbFrames);
			nbFrames = 0;
			lastTime += 1.0;
		}
		//printf("%d frame number\n", frame);
		frame++;
		//object.writeVerticesToFile("ourMethodResult.txt");
		/*object.bodyVolume = 0.0f;
		for (int i = 0; i < groupNum; i++)
		{
			object.groups[i].groupVolume = 0.0f;
		}
		for (int i = 0; i < groupNum; i++)
		{
			for (auto tets : object.groups[i].tetrahedra)
			{
				object.groups[i].groupVolume += tets->calVolumeTetra();
			}
			object.bodyVolume += object.groups[i].groupVolume;
		}*/
		
		//std::cout << object.bodyVolume << std::endl;
		
	
		/*double totalKE = 0.0;
		for (int i = 0; i < objectUniqueVertices.size(); i++) {
			double speedSquared = objectUniqueVertices[i]->velx * objectUniqueVertices[i]->velx + objectUniqueVertices[i]->vely * objectUniqueVertices[i]->vely + objectUniqueVertices[i]->velz * objectUniqueVertices[i]->velz;
			double kineticEnergy = 0.5 * objectUniqueVertices[i]->vertexMass * speedSquared;
			totalKE += kineticEnergy;
		}*/
		//double totalMass = 0.0;
		//double centerX = 0.0;
		//double centerY = 0.0;
		//double centerZ = 0.0;

		//for (int i = 0; i < objectUniqueVertices.size(); i++) {
		//	double vertexMass = objectUniqueVertices[i]->vertexMass;
		//	double vertexX = objectUniqueVertices[i]->x;
		//	double vertexY = objectUniqueVertices[i]->y;
		//	double vertexZ = objectUniqueVertices[i]->z;

		//	totalMass += vertexMass;
		//	centerX += vertexX * vertexMass;
		//	centerY += vertexY * vertexMass;
		//	centerZ += vertexZ * vertexMass;
		//}

		//if (totalMass != 0) {
		//	centerX /= totalMass;
		//	centerY /= totalMass;
		//	centerZ /= totalMass;
		//}
		//else {
		//	// Handle the case where totalMass is 0 to avoid division by zero
		//	centerX = 0.0;
		//	centerY = 0.0;
		//	centerZ = 0.0;
		//}

		// Output the center of mass
		//std::cout << "Center of Mass: (" << centerX << ", " << centerY << ", " << centerZ << ")" << std::endl;

	}
	
	
	glfwTerminate();
	return 0;
}
